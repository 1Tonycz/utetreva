/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/naja/dist/Naja.esm.js":
/*!********************************************!*\
  !*** ./node_modules/naja/dist/Naja.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   Naja: () => (/* binding */ Naja),\n/* harmony export */   \"default\": () => (/* binding */ naja)\n/* harmony export */ });\n/*\n * Naja.js\n * 3.2.1\n *\n * by Jiří Pudil <https://jiripudil.cz>\n */\n// ready\nconst onDomReady = (callback) => {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', callback);\n    }\n    else {\n        callback();\n    }\n};\n\nclass UIHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        this.selector = '.ajax';\n        this.allowedOrigins = [window.location.origin];\n        this.handler = this.handleUI.bind(this);\n        naja.addEventListener('init', this.initialize.bind(this));\n    }\n    initialize() {\n        onDomReady(() => this.bindUI(window.document.body));\n        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {\n            const { snippet } = event.detail;\n            this.bindUI(snippet);\n        });\n    }\n    bindUI(element) {\n        const selector = `a${this.selector}`;\n        const bindElement = (element) => {\n            element.removeEventListener('click', this.handler);\n            element.addEventListener('click', this.handler);\n        };\n        if (element.matches(selector)) {\n            return bindElement(element);\n        }\n        const elements = element.querySelectorAll(selector);\n        elements.forEach((element) => bindElement(element));\n        const bindForm = (form) => {\n            form.removeEventListener('submit', this.handler);\n            form.addEventListener('submit', this.handler);\n        };\n        if (element instanceof HTMLFormElement) {\n            return bindForm(element);\n        }\n        const forms = element.querySelectorAll('form');\n        forms.forEach((form) => bindForm(form));\n    }\n    handleUI(event) {\n        const element = event.currentTarget;\n        const options = this.naja.prepareOptions();\n        const ignoreErrors = () => {\n            // don't reject the promise in case of an error as developers have no way of handling the rejection\n            // in this situation; errors should be handled in `naja.addEventListener('error', errorHandler)`\n        };\n        if (event instanceof MouseEvent) {\n            if (event.altKey || event.ctrlKey || event.shiftKey || event.metaKey || event.button) {\n                return;\n            }\n            this.clickElement(element, options, event).catch(ignoreErrors);\n            return;\n        }\n        const { submitter } = event;\n        if (this.selector === '' || element.matches(this.selector) || submitter?.matches(this.selector)) {\n            this.submitForm(submitter ?? element, options, event).catch(ignoreErrors);\n        }\n    }\n    async clickElement(element, options = {}, event) {\n        if (element instanceof HTMLAnchorElement) {\n            return this.processInteraction(element, 'GET', element.href, null, options, event);\n        }\n        if ((element instanceof HTMLInputElement || element instanceof HTMLButtonElement) && element.form) {\n            return this.submitForm(element, options, event);\n        }\n        throw new Error('Unsupported element in clickElement(): element must be an anchor or a submitter element attached to a form.');\n    }\n    async submitForm(formOrSubmitter, options = {}, event) {\n        let form;\n        let submitter = null;\n        if ((formOrSubmitter instanceof HTMLInputElement || formOrSubmitter instanceof HTMLButtonElement) && formOrSubmitter.form) {\n            // eslint-disable-next-line prefer-destructuring\n            form = formOrSubmitter.form;\n            submitter = formOrSubmitter;\n        }\n        else if (formOrSubmitter instanceof HTMLFormElement) {\n            form = formOrSubmitter;\n            submitter = event instanceof SubmitEvent ? event.submitter : null;\n        }\n        else {\n            throw new Error('Unsupported element in submitForm(): formOrSubmitter must be either a form or a submitter element attached to a form.');\n        }\n        const method = (submitter?.getAttribute('formmethod') ?? form.getAttribute('method') ?? 'GET').toUpperCase();\n        const url = submitter?.getAttribute('formaction') ?? form.getAttribute('action') ?? window.location.pathname + window.location.search;\n        const data = new FormData(form, submitter);\n        return this.processInteraction(submitter ?? form, method, url, data, options, event);\n    }\n    async processInteraction(element, method, url, data = null, options = {}, event) {\n        if (!this.dispatchEvent(new CustomEvent('interaction', { cancelable: true, detail: { element, originalEvent: event, options } }))) {\n            event?.preventDefault();\n            return {};\n        }\n        if (!this.isUrlAllowed(`${url}`)) {\n            throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);\n        }\n        event?.preventDefault();\n        return this.naja.makeRequest(method, url, data, options);\n    }\n    isUrlAllowed(url) {\n        const urlObject = new URL(url, location.href);\n        // ignore non-URL URIs (javascript:, data:, mailto:, ...)\n        if (urlObject.origin === 'null') {\n            return false;\n        }\n        return this.allowedOrigins.includes(urlObject.origin);\n    }\n}\n\nclass FormsHandler {\n    constructor(naja) {\n        this.naja = naja;\n        naja.addEventListener('init', this.initialize.bind(this));\n        naja.uiHandler.addEventListener('interaction', this.processForm.bind(this));\n    }\n    initialize() {\n        onDomReady(() => this.initForms(window.document.body));\n        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {\n            const { snippet } = event.detail;\n            this.initForms(snippet);\n        });\n    }\n    initForms(element) {\n        const netteForms = this.netteForms || window.Nette;\n        if (!netteForms) {\n            return;\n        }\n        if (element instanceof HTMLFormElement) {\n            netteForms.initForm(element);\n            return;\n        }\n        const forms = element.querySelectorAll('form');\n        forms.forEach((form) => netteForms.initForm(form));\n    }\n    processForm(event) {\n        const { element, originalEvent } = event.detail;\n        const isForm = element instanceof HTMLFormElement;\n        const isSubmitter = (element instanceof HTMLInputElement || element instanceof HTMLButtonElement) && element.form;\n        if (isSubmitter) {\n            element.form['nette-submittedBy'] = element;\n        }\n        const netteForms = this.netteForms || window.Nette;\n        if ((isForm || isSubmitter) && netteForms && !netteForms.validateForm(element)) {\n            originalEvent?.stopImmediatePropagation();\n            originalEvent?.preventDefault();\n            event.preventDefault();\n        }\n    }\n}\n\nclass RedirectHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        naja.uiHandler.addEventListener('interaction', (event) => {\n            const { element, options } = event.detail;\n            if (element.hasAttribute('data-naja-force-redirect') || element.form?.hasAttribute('data-naja-force-redirect')) {\n                const value = element.getAttribute('data-naja-force-redirect') ?? element.form?.getAttribute('data-naja-force-redirect');\n                options.forceRedirect = value !== 'off';\n            }\n        });\n        naja.addEventListener('success', (event) => {\n            const { payload, options } = event.detail;\n            if (!payload.redirect) {\n                return;\n            }\n            this.makeRedirect(payload.redirect, options.forceRedirect ?? false, options);\n            event.stopImmediatePropagation();\n        });\n        this.locationAdapter = {\n            assign: (url) => window.location.assign(url),\n        };\n    }\n    makeRedirect(url, force, options = {}) {\n        if (url instanceof URL) {\n            url = url.href;\n        }\n        let isHardRedirect = force || !this.naja.uiHandler.isUrlAllowed(url);\n        const canRedirect = this.dispatchEvent(new CustomEvent('redirect', {\n            cancelable: true,\n            detail: {\n                url,\n                setUrl(value) {\n                    url = value;\n                },\n                isHardRedirect,\n                setHardRedirect(value) {\n                    isHardRedirect = !!value;\n                },\n                options,\n            },\n        }));\n        if (!canRedirect) {\n            return;\n        }\n        if (isHardRedirect) {\n            this.locationAdapter.assign(url);\n        }\n        else {\n            this.naja.makeRequest('GET', url, null, options);\n        }\n    }\n}\n\nclass SnippetHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.op = {\n            replace: {\n                updateElement(snippet, content) {\n                    snippet.innerHTML = content;\n                },\n                updateIndex(_, newContent) {\n                    return newContent;\n                },\n            },\n            prepend: {\n                updateElement(snippet, content) {\n                    snippet.insertAdjacentHTML('afterbegin', content);\n                },\n                updateIndex(currentContent, newContent) {\n                    return newContent + currentContent;\n                },\n            },\n            append: {\n                updateElement(snippet, content) {\n                    snippet.insertAdjacentHTML('beforeend', content);\n                },\n                updateIndex(currentContent, newContent) {\n                    return currentContent + newContent;\n                },\n            },\n        };\n        naja.addEventListener('success', (event) => {\n            const { options, payload } = event.detail;\n            if (!payload.snippets) {\n                return;\n            }\n            this.updateSnippets(payload.snippets, false, options);\n        });\n    }\n    static findSnippets(predicate, document = window.document) {\n        const result = {};\n        const snippets = document.querySelectorAll('[id^=\"snippet-\"]');\n        snippets.forEach((snippet) => {\n            if (predicate?.(snippet) ?? true) {\n                result[snippet.id] = snippet.innerHTML;\n            }\n        });\n        return result;\n    }\n    async updateSnippets(snippets, fromCache = false, options = {}) {\n        await Promise.all(Object.keys(snippets).map(async (id) => {\n            const snippet = document.getElementById(id);\n            if (snippet) {\n                await this.updateSnippet(snippet, snippets[id], fromCache, options);\n            }\n        }));\n    }\n    async updateSnippet(snippet, content, fromCache, options) {\n        let operation = this.op.replace;\n        if ((snippet.hasAttribute('data-naja-snippet-prepend') || snippet.hasAttribute('data-ajax-prepend')) && !fromCache) {\n            operation = this.op.prepend;\n        }\n        else if ((snippet.hasAttribute('data-naja-snippet-append') || snippet.hasAttribute('data-ajax-append')) && !fromCache) {\n            operation = this.op.append;\n        }\n        const canUpdate = this.dispatchEvent(new CustomEvent('beforeUpdate', {\n            cancelable: true,\n            detail: {\n                snippet,\n                content,\n                fromCache,\n                operation,\n                changeOperation(value) {\n                    operation = value;\n                },\n                options,\n            },\n        }));\n        if (!canUpdate) {\n            return;\n        }\n        this.dispatchEvent(new CustomEvent('pendingUpdate', {\n            detail: {\n                snippet,\n                content,\n                fromCache,\n                operation,\n                options,\n            },\n        }));\n        const updateElement = typeof operation === 'function' ? operation : operation.updateElement;\n        await updateElement(snippet, content);\n        this.dispatchEvent(new CustomEvent('afterUpdate', {\n            detail: {\n                snippet,\n                content,\n                fromCache,\n                operation,\n                options,\n            },\n        }));\n    }\n}\n\nconst originalTitleKey = Symbol();\nclass HistoryHandler extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        this.initialized = false;\n        this.cursor = 0;\n        this.popStateHandler = this.handlePopState.bind(this);\n        naja.addEventListener('init', this.initialize.bind(this));\n        naja.addEventListener('before', this.saveUrl.bind(this));\n        naja.addEventListener('before', this.saveOriginalTitle.bind(this));\n        naja.addEventListener('before', this.replaceInitialState.bind(this));\n        naja.addEventListener('success', this.pushNewState.bind(this));\n        naja.redirectHandler.addEventListener('redirect', this.saveRedirectedUrl.bind(this));\n        naja.uiHandler.addEventListener('interaction', this.configureMode.bind(this));\n        this.historyAdapter = {\n            replaceState: (state, title, url) => window.history.replaceState(state, title, url),\n            pushState: (state, title, url) => window.history.pushState(state, title, url),\n        };\n    }\n    set uiCache(value) {\n        console.warn('Naja: HistoryHandler.uiCache is deprecated, use options.snippetCache instead.');\n        this.naja.defaultOptions.snippetCache = value;\n    }\n    handlePopState(event) {\n        const { state } = event;\n        if (state?.source !== 'naja') {\n            return;\n        }\n        const direction = state.cursor - this.cursor;\n        this.cursor = state.cursor;\n        const options = this.naja.prepareOptions();\n        this.dispatchEvent(new CustomEvent('restoreState', { detail: { state, direction, options } }));\n    }\n    initialize() {\n        window.addEventListener('popstate', this.popStateHandler);\n    }\n    saveOriginalTitle(event) {\n        const { options } = event.detail;\n        options[originalTitleKey] = window.document.title;\n    }\n    saveUrl(event) {\n        const { url, options } = event.detail;\n        options.href ??= url;\n    }\n    saveRedirectedUrl(event) {\n        const { url, options } = event.detail;\n        options.href = url;\n    }\n    replaceInitialState(event) {\n        const { options } = event.detail;\n        const mode = HistoryHandler.normalizeMode(options.history);\n        if (mode !== false && !this.initialized) {\n            onDomReady(() => this.historyAdapter.replaceState(this.buildState(window.location.href, 'replace', this.cursor, options), window.document.title, window.location.href));\n            this.initialized = true;\n        }\n    }\n    configureMode(event) {\n        const { element, options } = event.detail;\n        if (element.hasAttribute('data-naja-history') || element.form?.hasAttribute('data-naja-history')) {\n            const value = element.getAttribute('data-naja-history') ?? element.form?.getAttribute('data-naja-history');\n            options.history = HistoryHandler.normalizeMode(value);\n        }\n    }\n    static normalizeMode(mode) {\n        if (mode === 'off' || mode === false) {\n            return false;\n        }\n        else if (mode === 'replace') {\n            return 'replace';\n        }\n        return true;\n    }\n    pushNewState(event) {\n        const { payload, options } = event.detail;\n        const mode = HistoryHandler.normalizeMode(options.history);\n        if (mode === false) {\n            return;\n        }\n        if (payload.postGet && payload.url) {\n            options.href = payload.url;\n        }\n        const method = mode === 'replace' ? 'replaceState' : 'pushState';\n        const cursor = mode === 'replace' ? this.cursor : ++this.cursor;\n        const state = this.buildState(options.href, mode, cursor, options);\n        // before the state is pushed into history, revert to the original title\n        const newTitle = window.document.title;\n        window.document.title = options[originalTitleKey];\n        this.historyAdapter[method](state, newTitle, options.href);\n        // after the state is pushed into history, update back to the new title\n        window.document.title = newTitle;\n    }\n    buildState(href, mode, cursor, options) {\n        const state = {\n            source: 'naja',\n            cursor,\n            href,\n        };\n        this.dispatchEvent(new CustomEvent('buildState', {\n            detail: {\n                state,\n                operation: mode === 'replace' ? 'replaceState' : 'pushState',\n                options,\n            },\n        }));\n        return state;\n    }\n}\n\nclass SnippetCache extends EventTarget {\n    constructor(naja) {\n        super();\n        this.naja = naja;\n        this.currentSnippets = new Map();\n        this.storages = {\n            off: new OffCacheStorage(naja),\n            history: new HistoryCacheStorage(),\n            session: new SessionCacheStorage(),\n        };\n        naja.addEventListener('init', this.initializeIndex.bind(this));\n        naja.snippetHandler.addEventListener('pendingUpdate', this.updateIndex.bind(this));\n        naja.uiHandler.addEventListener('interaction', this.configureCache.bind(this));\n        naja.historyHandler.addEventListener('buildState', this.buildHistoryState.bind(this));\n        naja.historyHandler.addEventListener('restoreState', this.restoreHistoryState.bind(this));\n    }\n    resolveStorage(option) {\n        let storageType;\n        if (option === true || option === undefined) {\n            storageType = 'history';\n        }\n        else if (option === false) {\n            storageType = 'off';\n        }\n        else {\n            storageType = option;\n        }\n        return this.storages[storageType];\n    }\n    static shouldCacheSnippet(snippet) {\n        return !snippet.hasAttribute('data-naja-history-nocache')\n            && !snippet.hasAttribute('data-history-nocache')\n            && (!snippet.hasAttribute('data-naja-snippet-cache')\n                || snippet.getAttribute('data-naja-snippet-cache') !== 'off');\n    }\n    initializeIndex() {\n        onDomReady(() => {\n            const currentSnippets = SnippetHandler.findSnippets(SnippetCache.shouldCacheSnippet);\n            this.currentSnippets = new Map(Object.entries(currentSnippets));\n        });\n    }\n    updateIndex(event) {\n        const { snippet, content, operation } = event.detail;\n        if (!SnippetCache.shouldCacheSnippet(snippet)) {\n            return;\n        }\n        const currentContent = this.currentSnippets.get(snippet.id) ?? '';\n        const updateIndex = typeof operation === 'object'\n            ? operation.updateIndex\n            : () => content;\n        this.currentSnippets.set(snippet.id, updateIndex(currentContent, content));\n        // update nested snippets\n        const snippetContent = SnippetCache.parser.parseFromString(content, 'text/html');\n        const nestedSnippets = SnippetHandler.findSnippets(SnippetCache.shouldCacheSnippet, snippetContent);\n        for (const [id, content] of Object.entries(nestedSnippets)) {\n            this.currentSnippets.set(id, content);\n        }\n    }\n    configureCache(event) {\n        const { element, options } = event.detail;\n        if (!element) {\n            return;\n        }\n        if (element.hasAttribute('data-naja-snippet-cache') || element.form?.hasAttribute('data-naja-snippet-cache')\n            || element.hasAttribute('data-naja-history-cache') || element.form?.hasAttribute('data-naja-history-cache')) {\n            const value = element.getAttribute('data-naja-snippet-cache')\n                ?? element.form?.getAttribute('data-naja-snippet-cache')\n                ?? element.getAttribute('data-naja-history-cache')\n                ?? element.form?.getAttribute('data-naja-history-cache');\n            options.snippetCache = value;\n        }\n    }\n    buildHistoryState(event) {\n        const { state, options } = event.detail;\n        if ('historyUiCache' in options) {\n            console.warn('Naja: options.historyUiCache is deprecated, use options.snippetCache instead.');\n            options.snippetCache = options.historyUiCache;\n        }\n        const presentSnippetIds = Object.keys(SnippetHandler.findSnippets(SnippetCache.shouldCacheSnippet));\n        const snippets = Object.fromEntries(Array.from(this.currentSnippets).filter(([id]) => presentSnippetIds.includes(id)));\n        if (!this.dispatchEvent(new CustomEvent('store', { cancelable: true, detail: { snippets, state, options } }))) {\n            return;\n        }\n        const storage = this.resolveStorage(options.snippetCache);\n        state.snippets = {\n            storage: storage.type,\n            key: storage.store(snippets),\n        };\n    }\n    restoreHistoryState(event) {\n        const { state, options } = event.detail;\n        if (state.snippets === undefined) {\n            return;\n        }\n        options.snippetCache = state.snippets.storage;\n        if (!this.dispatchEvent(new CustomEvent('fetch', { cancelable: true, detail: { state, options } }))) {\n            return;\n        }\n        const storage = this.resolveStorage(options.snippetCache);\n        const snippets = storage.fetch(state.snippets.key, state, options);\n        if (snippets === null) {\n            return;\n        }\n        if (!this.dispatchEvent(new CustomEvent('restore', { cancelable: true, detail: { snippets, state, options } }))) {\n            return;\n        }\n        this.naja.snippetHandler.updateSnippets(snippets, true, options);\n    }\n}\nSnippetCache.parser = new DOMParser();\nclass OffCacheStorage {\n    constructor(naja) {\n        this.naja = naja;\n        this.type = 'off';\n    } // eslint-disable-line no-empty-function\n    store() {\n        return null;\n    }\n    fetch(key, state, options) {\n        this.naja.makeRequest('GET', state.href, null, {\n            ...options,\n            history: false,\n            snippetCache: false,\n        });\n        return null;\n    }\n}\nclass HistoryCacheStorage {\n    constructor() {\n        this.type = 'history';\n    }\n    store(data) {\n        return data;\n    }\n    fetch(key) {\n        return key;\n    }\n}\nclass SessionCacheStorage {\n    constructor() {\n        this.type = 'session';\n    }\n    store(data) {\n        const key = Math.random().toString(36).substring(2, 8);\n        window.sessionStorage.setItem(key, JSON.stringify(data));\n        return key;\n    }\n    fetch(key) {\n        const data = window.sessionStorage.getItem(key);\n        if (data === null) {\n            return null;\n        }\n        return JSON.parse(data);\n    }\n}\n\nclass ScriptLoader {\n    constructor(naja) {\n        this.naja = naja;\n        this.loadedScripts = new Set();\n        naja.addEventListener('init', this.initialize.bind(this));\n    }\n    initialize() {\n        onDomReady(() => {\n            document.querySelectorAll('script[data-naja-script-id]').forEach((script) => {\n                const scriptId = script.getAttribute('data-naja-script-id');\n                if (scriptId !== null && scriptId !== '') {\n                    this.loadedScripts.add(scriptId);\n                }\n            });\n        });\n        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {\n            const { content } = event.detail;\n            this.loadScripts(content);\n        });\n    }\n    loadScripts(snippetsOrSnippet) {\n        if (typeof snippetsOrSnippet === 'string') {\n            this.loadScriptsInSnippet(snippetsOrSnippet);\n            return;\n        }\n        Object.keys(snippetsOrSnippet).forEach((id) => {\n            const content = snippetsOrSnippet[id];\n            this.loadScriptsInSnippet(content);\n        });\n    }\n    loadScriptsInSnippet(content) {\n        if (!/<script/i.test(content)) {\n            return;\n        }\n        const snippetContent = ScriptLoader.parser.parseFromString(content, 'text/html');\n        const scripts = snippetContent.querySelectorAll('script');\n        scripts.forEach((script) => {\n            const scriptId = script.getAttribute('data-naja-script-id');\n            if (scriptId !== null && scriptId !== '' && this.loadedScripts.has(scriptId)) {\n                return;\n            }\n            const scriptEl = window.document.createElement('script');\n            scriptEl.innerHTML = script.innerHTML;\n            if (script.hasAttributes()) {\n                for (const attribute of script.attributes) {\n                    scriptEl.setAttribute(attribute.name, attribute.value);\n                }\n            }\n            window.document.head.appendChild(scriptEl)\n                .parentNode.removeChild(scriptEl);\n            if (scriptId !== null && scriptId !== '') {\n                this.loadedScripts.add(scriptId);\n            }\n        });\n    }\n}\nScriptLoader.parser = new DOMParser();\n\nclass Naja extends EventTarget {\n    constructor(uiHandler, redirectHandler, snippetHandler, formsHandler, historyHandler, snippetCache, scriptLoader) {\n        super();\n        this.VERSION = 3;\n        this.initialized = false;\n        this.extensions = [];\n        this.defaultOptions = {};\n        this.uiHandler = new (uiHandler ?? UIHandler)(this);\n        this.redirectHandler = new (redirectHandler ?? RedirectHandler)(this);\n        this.snippetHandler = new (snippetHandler ?? SnippetHandler)(this);\n        this.formsHandler = new (formsHandler ?? FormsHandler)(this);\n        this.historyHandler = new (historyHandler ?? HistoryHandler)(this);\n        this.snippetCache = new (snippetCache ?? SnippetCache)(this);\n        this.scriptLoader = new (scriptLoader ?? ScriptLoader)(this);\n    }\n    registerExtension(extension) {\n        if (this.initialized) {\n            extension.initialize(this);\n        }\n        this.extensions.push(extension);\n    }\n    initialize(defaultOptions = {}) {\n        if (this.initialized) {\n            throw new Error('Cannot initialize Naja, it is already initialized.');\n        }\n        this.defaultOptions = this.prepareOptions(defaultOptions);\n        this.extensions.forEach((extension) => extension.initialize(this));\n        this.dispatchEvent(new CustomEvent('init', { detail: { defaultOptions: this.defaultOptions } }));\n        this.initialized = true;\n    }\n    prepareOptions(options) {\n        return {\n            ...this.defaultOptions,\n            ...options,\n            fetch: {\n                ...this.defaultOptions.fetch,\n                ...options?.fetch,\n            },\n        };\n    }\n    async makeRequest(method, url, data = null, options = {}) {\n        // normalize url to instanceof URL\n        if (typeof url === 'string') {\n            url = new URL(url, location.href);\n        }\n        options = this.prepareOptions(options);\n        const headers = new Headers(options.fetch.headers || {});\n        const body = this.transformData(url, method, data);\n        const abortController = new AbortController();\n        const request = new Request(url.toString(), {\n            credentials: 'same-origin',\n            ...options.fetch,\n            method,\n            headers,\n            body,\n            signal: abortController.signal,\n        });\n        // impersonate XHR so that Nette can detect isAjax()\n        request.headers.set('X-Requested-With', 'XMLHttpRequest');\n        // hint the server that Naja expects response to be JSON\n        request.headers.set('Accept', 'application/json');\n        if (!this.dispatchEvent(new CustomEvent('before', { cancelable: true, detail: { request, method, url: url.toString(), data, options } }))) {\n            return {};\n        }\n        const promise = window.fetch(request);\n        this.dispatchEvent(new CustomEvent('start', { detail: { request, promise, abortController, options } }));\n        let response, payload;\n        try {\n            response = await promise;\n            if (!response.ok) {\n                throw new HttpError(response);\n            }\n            payload = await response.json();\n        }\n        catch (error) {\n            if (error.name === 'AbortError') {\n                this.dispatchEvent(new CustomEvent('abort', { detail: { request, error, options } }));\n                this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));\n                return {};\n            }\n            this.dispatchEvent(new CustomEvent('error', { detail: { request, response, error, options } }));\n            this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));\n            throw error;\n        }\n        this.dispatchEvent(new CustomEvent('payload', { detail: { request, response, payload, options } }));\n        this.dispatchEvent(new CustomEvent('success', { detail: { request, response, payload, options } }));\n        this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload, error: undefined, options } }));\n        return payload;\n    }\n    appendToQueryString(searchParams, key, value) {\n        if (value === null || value === undefined) {\n            return;\n        }\n        if (Array.isArray(value) || Object.getPrototypeOf(value) === Object.prototype) {\n            for (const [subkey, subvalue] of Object.entries(value)) {\n                this.appendToQueryString(searchParams, `${key}[${subkey}]`, subvalue);\n            }\n        }\n        else {\n            searchParams.append(key, String(value));\n        }\n    }\n    transformData(url, method, data) {\n        const isGet = ['GET', 'HEAD'].includes(method.toUpperCase());\n        // sending a form via GET -> serialize FormData into URL and return empty request body\n        if (isGet && data instanceof FormData) {\n            for (const [key, value] of data) {\n                if (value !== null && value !== undefined) {\n                    url.searchParams.append(key, String(value));\n                }\n            }\n            return null;\n        }\n        // sending a POJO -> serialize it recursively into URLSearchParams\n        const isDataPojo = data !== null && Object.getPrototypeOf(data) === Object.prototype;\n        if (isDataPojo || Array.isArray(data)) {\n            // for GET requests, append values to URL and return empty request body\n            // otherwise build `new URLSearchParams()` to act as the request body\n            const transformedData = isGet ? url.searchParams : new URLSearchParams();\n            for (const [key, value] of Object.entries(data)) {\n                this.appendToQueryString(transformedData, key, value);\n            }\n            return isGet\n                ? null\n                : transformedData;\n        }\n        return data;\n    }\n}\nclass HttpError extends Error {\n    constructor(response) {\n        const message = `HTTP ${response.status}: ${response.statusText}`;\n        super(message);\n        this.name = this.constructor.name;\n        this.stack = new Error(message).stack;\n        this.response = response;\n    }\n}\n\nclass AbortExtension {\n    constructor() {\n        this.abortControllers = new Set();\n    }\n    initialize(naja) {\n        naja.uiHandler.addEventListener('interaction', this.checkAbortable.bind(this));\n        naja.addEventListener('init', this.onInitialize.bind(this));\n        naja.addEventListener('start', this.saveAbortController.bind(this));\n        naja.addEventListener('complete', this.removeAbortController.bind(this));\n    }\n    onInitialize() {\n        document.addEventListener('keydown', (event) => {\n            if (event.key === 'Escape' && !(event.ctrlKey || event.shiftKey || event.altKey || event.metaKey)) {\n                for (const controller of this.abortControllers) {\n                    controller.abort();\n                }\n                this.abortControllers.clear();\n            }\n        });\n    }\n    checkAbortable(event) {\n        const { element, options } = event.detail;\n        if (element.hasAttribute('data-naja-abort') || element.form?.hasAttribute('data-naja-abort')) {\n            options.abort = (element.getAttribute('data-naja-abort') ?? element.form?.getAttribute('data-naja-abort')) !== 'off';\n        }\n    }\n    saveAbortController(event) {\n        const { abortController, options } = event.detail;\n        if (options.abort !== false) {\n            this.abortControllers.add(abortController);\n            options.clearAbortExtension = () => this.abortControllers.delete(abortController);\n        }\n    }\n    removeAbortController(event) {\n        const { options } = event.detail;\n        if (options.abort !== false && !!options.clearAbortExtension) {\n            options.clearAbortExtension();\n        }\n    }\n}\n\nclass UniqueExtension {\n    constructor() {\n        this.abortControllers = new Map();\n    }\n    initialize(naja) {\n        naja.uiHandler.addEventListener('interaction', this.checkUniqueness.bind(this));\n        naja.addEventListener('start', this.abortPreviousRequest.bind(this));\n        naja.addEventListener('complete', this.clearRequest.bind(this));\n    }\n    checkUniqueness(event) {\n        const { element, options } = event.detail;\n        if (element.hasAttribute('data-naja-unique') ?? element.form?.hasAttribute('data-naja-unique')) {\n            const unique = element.getAttribute('data-naja-unique') ?? element.form?.getAttribute('data-naja-unique');\n            options.unique = unique === 'off' ? false : unique ?? 'default';\n        }\n    }\n    abortPreviousRequest(event) {\n        const { abortController, options } = event.detail;\n        if (options.unique !== false) {\n            this.abortControllers.get(options.unique ?? 'default')?.abort();\n            this.abortControllers.set(options.unique ?? 'default', abortController);\n        }\n    }\n    clearRequest(event) {\n        const { request, options } = event.detail;\n        if (!request.signal.aborted && options.unique !== false) {\n            this.abortControllers.delete(options.unique ?? 'default');\n        }\n    }\n}\n\nconst naja = new Naja();\nnaja.registerExtension(new AbortExtension());\nnaja.registerExtension(new UniqueExtension());\n\n\n//# sourceMappingURL=Naja.esm.js.map\n\n\n//# sourceURL=webpack:///./node_modules/naja/dist/Naja.esm.js?\n}");

/***/ }),

/***/ "./scripts/master.js":
/*!***************************!*\
  !*** ./scripts/master.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var naja__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! naja */ \"./node_modules/naja/dist/Naja.esm.js\");\n\r\n\r\nnaja__WEBPACK_IMPORTED_MODULE_0__[\"default\"].initialize();\r\n\n\n//# sourceURL=webpack:///./scripts/master.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./scripts/master.js");
/******/ 	
/******/ })()
;